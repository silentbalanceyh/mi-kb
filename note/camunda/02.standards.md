---
title: 规范详解
---

官方站点：<http://www.omg.org/>

# 1. 建模一致性

* 附件：[BPMN 2.0](/note/camunda/pdf/BPMN%202.0.pdf)

## 1.1. 流程建模一致性

|BPMN包|说明|
|---|---|
|BPMN核心元素|包含基础结构、基础、公共和服务中定义的元素包。|
|流程图|包含流程、活动、数据和人员交互中定义的元素。|
|协作图|包括池和消息流。|
|会话图|包含池、会话和会话链接。|

&ensp;&ensp;&ensp;&ensp;完整建模一致性，BPMN中定义了三个子类：

|原文|子类|说明|
|---|---|---|
|Descriptive|描述性|和高级建模中可见元素和属性有关。|
|Analytic|分析性|包含完整过程建模中符合所有描述性的元素等。|
|Common Executable|通用可执行文件|专注于可执行流程模型所需元素。|

> BPMN 2.0不支持编排模型，下边表格为XML中的Element和Attribute。

&ensp;&ensp;&ensp;&ensp;支持子类的工具必须满足下边条件：

* 必须支持子类中所有元素。
* 对每个元素，必须支持所有列出的属性。
* 通常，如果子类未提及属性且架构上没有要求，则该属性不在子类中。

> 详细内容参考附件中的`2.2.2 BPMN Process Elements`

# 2. BPMN 2.0

## 2.1. BPMN范围（Scope）

&ensp;&ensp;&ensp;&ensp;以下是从BPMN 1.2扩展的范围和功能：

* 正规化所有BPMN元素和执行语义。
* 为流程模型扩展和图形扩展定义可扩展性机制。
* 完善事件的组成和相关性。
* 扩展和人互动的定义。
* 定义编排模型。

&ensp;&ensp;&ensp;&ensp;以下是超出国际标准范围的部分：

* 定义组织模型和资源
* 功能故障建模
* 数据和信息模型
* 策略模型
* 业务规则模型

## 2.2. BPMN用途

&ensp;&ensp;&ensp;&ensp;端到端BPMN模型中存在三种子模型：

* 流程（编排）：
    * 私有的非可执行（内部）业务流程
    * 私有可执行（内部）业务流程
    * 公共程序
* 组合流程（Choreographies）
* 写作，包括流程/编排
    * 对话视图（Conversations）

### 2.2.1. 私有业务流程

![](_image/2021-11-04-14-02-00.png)

&ensp;&ensp;&ensp;&ensp;私有进程有两种类型：**可执行/不可执行**——不可执行流程是已建模的专用流程，目的是在建模者定义的详细级别上记录流程行为。

### 2.2.2. 公共程序

![](_image/2021-11-04-14-11-10.png)

&ensp;&ensp;&ensp;&ensp;公共流程表示私有业务流程与另一个流程或参与者之间的交互，公共流程中仅包括那些用于与其他参与者交流的活动，原图中没有下边这个框，Modeler中目前没找到绘制的方法（下边是原图）。

![](_image/2021-11-04-14-16-02.png)

### 2.2.3. 协同合作

&ensp;&ensp;&ensp;&ensp;协作描述了两个或多个业务实体之间的交互，通常包含两个或多个池，代表协作中的参与者，此时直接连接池中对象。

![](_image/2021-11-04-14-19-56.png)

### 2.2.4. 组合流程

&ensp;&ensp;&ensp;&ensp;独立的组合流程（无池或编排）表示交互参与者之间预期行为的定义，一般为程序上的契约，它看起来比较像私有业务流程，由活动、事件和网关组成。编排和私有不同的地方是一个“活动”代表一组消息交换的交互，涉及两个或多个参与者（**中英双份**）。

![](_image/2021-11-04-14-24-07.png)

![](_image/2021-11-04-14-25-07.png)

### 2.2.5. 会话图

&ensp;&ensp;&ensp;&ensp;会话图是协作图中的一种特殊用法，也是对协作图的非正式描述，但会话中不包含流程，通常不会在“对话”图的池之间放置编排（**中英双份**）。

![](_image/2021-11-04-14-27-07.png)

![](_image/2021-11-04-14-27-25.png)

## 2.3. BPMN元素

&ensp;&ensp;&ensp;&ensp;BPMN元素的五个基本类别：

1. 流对象：Flow Objects，定义业务流程行为的主要图形元素
    1. 事件：Events
    2. 活动项：Activities
    3. 网关：Gateways
2. 数据：Data
    1. 数据对象：Data Objects
    2. 数据输入：Data Inputs
    3. 数据输出：Data Outputs
    4. 数据存储库：Data Stores
3. 连接对象：Connecting Objects，有四种方法将这些对象彼此连接
    1. 顺序流：Sequence Flows
    2. 消息流：Message Flows
    3. 关联：Associations
    4. 数据关联：Data Associations
4. 泳道：Swimlanes，泳道负责将建模元素分组
    1. 池化：Pools
    2. 泳道：Lanes
5. 工件：Artifacts，用于提供有关流程的其他信息，有两个标准工件，建模者或工具也可以自定义。
    1. 组：Group
    2. 文字注解：Text Annotation

### 2.3.1. BPMN建模元素

|元素|符号|扩展符号|
|---|---|---|
|Event|![](_image/2021-11-04-14-37-44.png)|![](_image/2021-11-04-14-38-46.png)|
|Type Dimension||参考表格之后的完整定义表|
|Activity|![](_image/2021-11-04-14-43-12.png)||
|Task（Atomic）||![](_image/2021-11-04-14-47-57.png)|
|Choreography Task||![](_image/2021-11-04-14-48-18.png)|
|Process/Sub-Process（non-atomic）||参考之后四个子流程|
|Collapsed Sub-Process||![](_image/2021-11-04-14-49-36.png)|
|Expanded Sub-Process||![](_image/2021-11-04-14-49-56.png)|
|Collapsed Sub-Choreography||![](_image/2021-11-04-14-50-24.png)|
|Expanded Sub-Choreography||![](_image/2021-11-04-14-50-48.png)|
|Gateway|![](_image/2021-11-04-14-43-45.png)||
|Gateway Control Types||![](_image/2021-11-04-14-51-19.png)|
|Sequence Flow|![](_image/2021-11-04-14-44-15.png)||
|Normal Flow||![](_image/2021-11-04-14-52-18.png)|
|Uncontrolled Flow||![](_image/2021-11-04-14-52-38.png)|
|Conditional Flow||![](_image/2021-11-04-14-52-56.png)|
|Default Flow||![](_image/2021-11-04-14-53-16.png)|
|Exception Flow||![](_image/2021-11-04-14-53-54.png)|
|Message Flow|![](_image/2021-11-04-14-44-46.png)||
|Association|![](_image/2021-11-04-14-45-08.png)||
|Compensation Association||![](_image/2021-11-04-14-54-37.png)|
|Pool|![](_image/2021-11-04-14-45-33.png)||
|Lane|![](_image/2021-11-04-14-45-50.png)||
|Data Object|![](_image/2021-11-04-14-46-12.png)||
|Data Object||![](_image/2021-11-04-14-55-00.png)|
|Message|![](_image/2021-11-04-14-46-30.png)||
|Group|![](_image/2021-11-04-14-46-49.png)||
|Text Annotation|![](_image/2021-11-04-14-47-16.png)||
|**以下元素是非基本元素扩展**|
|Fork||![](_image/2021-11-04-14-56-28.png)|
|Join||![](_image/2021-11-04-14-57-10.png)|
|Decision, Branching Point|查看下边四种（选择类控制流程）||
|Exclusive||![](_image/2021-11-04-14-57-48.png)|
|Event-Based||![](_image/2021-11-04-14-58-12.png)|
|Inclusive|||![](_image/2021-11-04-14-58-33.png)|
|Merging||![](_image/2021-11-04-14-59-14.png)|
|Looping|查看下边两种（循环类控制流程）||
|Activity Looping||![](_image/2021-11-04-14-59-51.png)|
|Sequence Flow Looping||![](_image/2021-11-04-15-00-11.png)|
|Multiple Instances||![](_image/2021-11-04-15-00-35.png)|
|Process Break||![](_image/2021-11-04-15-00-53.png)|
|Transaction||![](_image/2021-11-04-15-01-10.png)|
|Nested/Embedded Sub-Process||无图标对应|
|Off-Page Connector||![](_image/2021-11-04-15-02-10.png)|

**完整定义表**

![](_image/2021-11-04-14-40-23.png)

## 2.4. BPMN图类型

&ensp;&ensp;&ensp;&ensp;以下是使用BPMN 2.0可以建模的业务流程示例：

* 高级别非可执行活动流程（非功能细分）
* 详细的可执行业务流程
* 原样或旧业务流程
* 准或新业务流程
* 两个或更多业务者参与（组合）之间预期行为的描述
* 详细的私有业务流程（可执行/不可执行），与一个或多个外部交互实体
* 两个或更多详细的可执行进程进行交互
* 与编排的详细的可执行业务流程关系
* 两个或多个公共流程
* 与编排的公共流程关系
* 通过编排进行交互的两个或更多详细可执行业务流程

## 2.5. 流对象连接规则

> `o`符号表示这个对象之间可以直接做连接。

### 2.5.1. 顺序流

|From/To|![](_image/2021-11-04-15-16-52.png)|![](_image/2021-11-04-15-17-06.png)|![](_image/2021-11-04-15-17-51.png)|![](_image/2021-11-04-15-18-01.png)|![](_image/2021-11-04-15-18-11.png)|![](_image/2021-11-04-15-18-29.png)|
|---|---|---|---|---|---|---|
|![](_image/2021-11-04-15-16-52.png)||‰|o|o|o|o|
|![](_image/2021-11-04-15-17-06.png)||‰|o|o|o|o|
|![](_image/2021-11-04-15-17-51.png)||‰|o|o|o|o|
|![](_image/2021-11-04-15-18-01.png)||‰|o|o|o|o|
|![](_image/2021-11-04-15-18-11.png)||‰|o|o|o|o|
|![](_image/2021-11-04-15-18-29.png)||||||

### 2.5.2. 消息流

|From/To|![](_image/2021-11-04-15-22-34.png)|![](_image/2021-11-04-15-22-44.png)|![](_image/2021-11-04-15-22-56.png)|![](_image/2021-11-04-15-23-08.png)|![](_image/2021-11-04-15-23-19.png)|![](_image/2021-11-04-15-23-34.png)|
|---|---|---|---|---|---|---|
|![](_image/2021-11-04-15-22-34.png)|||||||
|![](_image/2021-11-04-15-22-44.png)|^|o|o|o|o||
|![](_image/2021-11-04-15-22-56.png)|^|o|o|o|o||
|![](_image/2021-11-04-15-23-08.png)|^|o|o|o|o||
|![](_image/2021-11-04-15-23-19.png)|^|o|o|o|o||
|![](_image/2021-11-04-15-23-34.png)|^|o|o|o|o||

## 2.6. BPMN核心结构

![](_image/2021-11-04-15-29-26.png)

&ensp;&ensp;&ensp;&ensp;核心包含四个子包：

1. Infrastructure：用于抽象语法模型和图模型两个元素
2. Foundation：BPMN建模所需的基本构造
3. Service：对服务和接口进行建模所需的基本构造
4. Common：处理，编排和写作各层公有类

![](_image/2021-11-04-15-31-43.png)

&ensp;&ensp;&ensp;&ensp;其他所有详细内容和原理参考附件中的其他部分，本文主要处理图形部分，然后结合Camunda教程定义相关流程以及在产品中集成这部分内容。

# 3. Comunda对BPMN 2.0的支持

* **橙色**是支持的符号元素，黑色是不支持的。

## 3.1. Symbol: Participants

![](_image/2021-11-04-15-46-15.png)

## 3.2. Symbol: Subprocesses

![](_image/2021-11-04-15-46-46.png)

## 3.3. Symbol: Tasks

![](_image/2021-11-04-15-47-34.png)

## 3.4. Symbol：Gateway

![](_image/2021-11-04-15-48-01.png)

## 3.5. Symbol：Data/Artifacts

![](_image/2021-11-04-15-48-36.png)

## 3.6. Event

![](_image/2021-11-04-14-40-23.png)

# 4. Comunda中BPMN任务

## 4.1. 服务任务：Service Task

![](_image/2021-11-04-15-50-50.png)

### 4.1.1. 基本调用

&ensp;&ensp;&ensp;&ensp;四种定义和Java调用逻辑：

* 定义一个实现了`JavaDelegate`或`ActivityBehavior`接口的类，`camunda:class`：

    ```xml
    <serviceTask id="javaService"
             name="My Java Service Task"
             camunda:class="org.camunda.bpm.MyJavaDelegate" />
    ```

* 使用表达式解析一个`delegation`的Java对象，`camunda:delegateExpression`：

    ```xml
    <serviceTask id="beanService"
             name="My Bean Service Task"
             camunda:delegateExpression="${myDelegateBean}" />
    ```
* 调用方法表达式或值表达式，`camunda:expression`：

    ```xml
    <serviceTask id="expressionService"
             name="My Expression Service Task"
             camunda:expression="${myBean.doWork()}" />
    ```

* 还有一种调用方法是直接使用`REST/SOAP`接口，`camunda:connector`。

### 4.1.2. Service Task执行结果

&ensp;&ensp;&ensp;&ensp;您可以将执行结果存储在变量中：

```xml
<serviceTask id="aMethodExpressionServiceTask"
           camunda:expression="#{myService.doSomething()}"
           camunda:resultVariable="myVar" />
```

### 4.1.3. External Task外联任务

```xml
<serviceTask id="anExternalServiceTask"
           camunda:type="external"
           camunda:topic="ShipmentProcessing" />
```

## 4.2. 发送任务：Send Task

![](_image/2021-11-04-15-58-59.png)

&ensp;&ensp;&ensp;&ensp;发送任务主要用来发送一个消息出去。

```xml
<sendTask id="sendTask" camunda:class="org.camunda.bpm.MySendTaskDelegate" />
```

## 4.3. 用户任务：User Task

![](_image/2021-11-04-16-00-11.png)

&ensp;&ensp;&ensp;&ensp;用户任务必须被人工执行和处理：

```xml
<userTask id="theTask" name="Important task" />
```

### 4.3.1. 任务描述

```xml
<userTask id="theTask" name="Schedule meeting" >
  <documentation>
      Schedule an engineering meeting for next week with the new hire.
  </documentation>
```

```java
// Java代码
task.getDescription();
```

### 4.3.2. 属性

&ensp;&ensp;&ensp;&ensp;下边片段用来定义该任务的最后期限：

```xml
<userTask id="theTask" name="Important task" camunda:dueDate="${dateVariable}"/>
```

&ensp;&ensp;&ensp;&ensp;下边片段用来定义下一个任务执行的时间：

```xml
<userTask id="theTask" name="Important task" camunda:followUpDate="${dateVariable}"/>
```

### 4.3.3. 派工

#### BPMN资源派工

1. 人工执行：Human Performer

    ```xml
    <userTask id='theTask' name='important task' >
        <humanPerformer>
            <resourceAssignmentExpression>
                <formalExpression>kermit</formalExpression>
            </resourceAssignmentExpression>
        </humanPerformer>
    </userTask>
    ```

    ```java
    // Java代码
    List<Task> tasks = taskService.createTaskQuery().taskAssignee("kermit").list();
    ```
2. 可能拥有者：Potential Owner

    ```xml
    <userTask id='theTask' name='important task' >
        <potentialOwner>
            <resourceAssignmentExpression>
                <formalExpression>user(kermit), group(management)</formalExpression>
            </resourceAssignmentExpression>
        </potentialOwner>
    </userTask>
    ```

    ```java
    // Java代码
    List<Task> tasks = taskService.createTaskQuery().taskCandidateUser("kermit");
    ```

    下边两段代码是等价的：

    ```xml
    <formalExpression>accountancy</formalExpression>
    <formalExpression>group(accountancy)</formalExpression>
    ```

#### Camunda扩展派工

1. 被派工者：Assignee

    ```xml
    <userTask id="theTask" name="my task" camunda:assignee="kermit" />
    ```
2. 候选用户：Candidate Users

    ```xml
    <userTask id="theTask" name="my task" camunda:candidateUsers="kermit, gonzo" />
    ```
3. 候选组：Condidate Groups

    ```xml
    <userTask id="theTask" name="my task" camunda:candidateGroups="management, accountancy" />
    ```
4. 组合候选用户和组

#### 基于服务逻辑和数据派工

1. 派工表达式：
    1. 流程变量

        ```xml
        <startEvent id="startEvent" camunda:initiator="starter" />
        <userTask id="task" name="Clarify Invoice" camunda:assignee="${ starter }"/>
        ```
    2. 调用服务/Bean

        ```xml
        <userTask id="task" name="My Task" camunda:assignee="${ldapService.findManagerForEmployee(emp)}"/>
        <userTask id="task" name="My Task" camunda:candidateUsers="${ldapService.findAllSales()}"/>
        ```

        ```java
        // Java代码
        public class FakeLdapService {
            public String findManagerForEmployee(String employee) {
                return "Kermit The Frog";
            }

            public List<String> findAllSales() {
                return Arrays.asList("kermit", "gonzo", "fozzie");
            }
        }
        ```
2. 监听器派工

    ```xml
    <userTask id="task1" name="My task" >
        <extensionElements>
            <camunda:taskListener event="create" class="org.camunda.bpm.MyAssignmentHandler" />
        </extensionElements>
    </userTask>
    ```

    ```java
    // Java代码
    public class MyAssignmentHandler implements TaskListener {
        public void notify(DelegateTask delegateTask) {
            // Execute custom identity lookups here
            // and then for example call following methods:
            delegateTask.setAssignee("kermit");
            delegateTask.addCandidateUser("fozzie");
            delegateTask.addCandidateGroup("management");
            // ...
        }
    }
    ```

#### 派工和标识服务

```java
// 标识服务
ProcessEngine processEngine = delegateTask.getProcessEngine();
IdentityService identityService = processEngine.getIdentityService();

List<User> managementUsers = identityService.createUserQuery()
    .memberOfGroup("management")
    .list();

User kermit = identityService.createUserQuery()
    .userFirstName("kermit")
    .singleResult();
```

### 4.3.4. 任务完成

```java
// 调用任务完成代码
taskService.complete(taskId, variables);

// or complete and retrieve the process variables
VariableMap processVariables = taskService
  .completeWithVariablesInReturn(taskId, variables, shouldDeserializeValues);
```

* 表单部分略，参考：[Task/Forms](https://docs.camunda.org/manual/7.16/reference/bpmn20/tasks/user-task/#forms)

## 4.4. 业务规则任务：Business Rule Task

![](_image/2021-11-04-16-21-27.png)

### 4.4.1. DMN Engine

&ensp;&ensp;&ensp;&ensp;属性`camunda:decisionRefBinding`的值列表如下：

* **deployment**：发布后版本
* **latest**：最新版

    ```xml
    <!-- 默认值 -->
    <businessRuleTask id="businessRuleTask"
        camunda:decisionRef="myDecision" />
    ```
* **version**：使用指定版本，配合`camunda:decisionRefVersion`

    ```xml
    <businessRuleTask id="businessRuleTask"
        camunda:decisionRef="myDecision"
        camunda:decisionRefBinding="version"
        camunda:decisionRefVersion="12" />
    <!-- 使用变量 -->
    <businessRuleTask id="businessRuleTask"
        camunda:decisionRef="${decisionKey}"
        camunda:decisionRefBinding="version"
        camunda:decisionRefVersion="${decisionVersion}" />
    ```
* **versionTag**：用来执行特定版本`camunda:decisionRefVersionTag`

&ensp;&ensp;&ensp;&ensp;使用`map`数据结构处理决策结果：

```xml
<businessRuleTask id="businessRuleTask"
    camunda:decisionRef="myDecision"
    camunda:mapDecisionResult="singleEntry"
    camunda:resultVariable="result" />
```

### 4.4.2. DecisionRef租户ID

&ensp;&ensp;&ensp;&ensp;默认情况`tenant id=null`，显示指定的情况：

1. `camunda:decisionRefTenantId`指定

    ```xml
    <businessRuleTask id="businessRuleTask" decisionRef="myDecision"
        camunda:decisionRefTenantId="TENANT_1">
    </businessRuleTask>
    ```
2. 如果`tenant id`未设计过：

    ```xml
    <businessRuleTask id="businessRuleTask" decisionRef="myDecision"
        camunda:decisionRefTenantId="${ myBean.calculateTenantId(variable) }">
    </businessRuleTask>
    ```
3. 调用流程实例：

    ```xml
    <businessRuleTask id="businessRuleTask" decisionRef="myDecision"
        camunda:decisionRefTenantId="${ execution.tenantId }">
    </businessRuleTask>
    ```

### 4.4.3. 自定义规则

```xml
<businessRuleTask id="businessRuleTask"
    camunda:delegateExpression="${MyRuleServiceDelegate}" />
```

## 4.5. 脚本任务：Script Task

![](_image/2021-11-04-16-30-56.png)

&ensp;&ensp;&ensp;&ensp;脚本任务定义（基于`JSR-223`）：

```xml
<scriptTask id="theScriptTask" name="Execute script" scriptFormat="groovy">
  <script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
  </script>
</scriptTask>
```

&ensp;&ensp;&ensp;&ensp;脚本中的变量（和Java交互）：

```xml
<!-- 从Java代码中读 -->
<script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
</script>
<!-- 将代码写入Java代码 -->
<script>
    sum = 0
    for ( i in inputArray ) {
      sum += i
    }
    execution.setVariable("sum", sum);
</script>
```

&ensp;&ensp;&ensp;&ensp;如果属性`autoStoreScriptVariables=true`则流程引擎会自动存储全局脚本变量，该功能为`7.0/7.1`版本中的默认功能。Script中的结果提取：

```xml
<scriptTask id="theScriptTask" name="Execute script" 
    scriptFormat="juel" camunda:resultVariable="myVar">
  <script>#{echo}</script>
</scriptTask>
```

## 4.6. 接收任务：Receive Task

![](_image/2021-11-04-16-35-54.png)

&ensp;&ensp;&ensp;&ensp;这种类型的任务通常会跟随一个`message`引用：

```xml
<definitions ...>
  <message id="newInvoice" name="newInvoiceMessage"/>
  <process ...>
    <receiveTask id="waitState" name="wait" messageRef="newInvoice">
  ...
```

&ensp;&ensp;&ensp;&ensp;Java代码中操作消息：

```java
// correlate the message
runtimeService.createMessageCorrelation(subscription.getEventName())
  .processInstanceBusinessKey("AB-123")
  .correlate();
// 订阅和触发
ProcessInstance pi = runtimeService.startProcessInstanceByKey("processWaitingInReceiveTask");

EventSubscription subscription = runtimeService.createEventSubscriptionQuery()
  .processInstanceId(pi.getId()).eventType("message").singleResult();

runtimeService.messageEventReceived(subscription.getEventName(), subscription.getExecutionId());
```

&ensp;&ensp;&ensp;&ensp;任务等待：

```xml
<receiveTask id="waitState" name="wait" />
```

```java
// Java代码调用
ProcessInstance pi = runtimeService.startProcessInstanceByKey("receiveTask");
Execution execution = runtimeService.createExecutionQuery()
  .processInstanceId(pi.getId()).activityId("waitState").singleResult();

runtimeService.signal(execution.getId());
```

## 4.7. 手工任务：Manual Task

![](_image/2021-11-04-16-39-06.png)

&ensp;&ensp;&ensp;&ensp;手工任务主要定义外置BPM引擎逻辑，用于手工执行该任务。

```xml
<manualTask id="myManualTask" name="Manual Task" />
```

## 4.8. 多任务实例

&ensp;&ensp;&ensp;&ensp;下边“活动（Activities）”实例可用来做多任务实例：

* Service Task
* Send Task
* User Task
* Business Rule Task
* Script Task
* Receive Task
* Manual Task
* （嵌入）Sub-Process
* Call Activity
* Transaction Subprocess

&ensp;&ensp;&ensp;&ensp;并行和串行专用任务：

![](_image/2021-11-04-16-43-07.png)

&ensp;&ensp;&ensp;&ensp;属性表：

|属性名|含义|
|---|---|
|nrOfInstances|实例总数量|
|nrOfActiveInstances|当前激活的实例总数，如果是顺序型，则通常是1|
|nrOfCompletedInstances|已经完成的实例数|

* loopCounter：`For Each`迭代循环时迭代的索引值。

```xml
<!--编排-->
<multiInstanceLoopCharacteristics isSequential="false|true">
</multiInstanceLoopCharacteristics>
<!--所有数值实例会计算一次-->
<multiInstanceLoopCharacteristics isSequential="false|true">
  <loopCardinality>5</loopCardinality>
</multiInstanceLoopCharacteristics>
<!--也可以使用负值-->
<multiInstanceLoopCharacteristics isSequential="false|true">
  <loopCardinality>${nrOfOrders-nrOfCancellations}</loopCardinality>
</multiInstanceLoopCharacteristics>
```

&ensp;&ensp;&ensp;&ensp;用户定义中使用**编排**：

```xml
<!--串行-->
<userTask id="miTasks" name="My Task ${loopCounter}" camunda:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="false">
    <loopDataInputRef>assigneeList</loopDataInputRef>
    <inputDataItem name="assignee" />
  </multiInstanceLoopCharacteristics>
</userTask>
<!--并行-->
<userTask id="miTasks" name="My Task" camunda:assignee="${assignee}">
  <multiInstanceLoopCharacteristics isSequential="true"
     camunda:collection="${myService.resolveUsersForTask()}" camunda:elementVariable="assignee" >
  </multiInstanceLoopCharacteristics>
</userTask>
```

### 4.8.1. 边界事件/多实例

![](_image/2021-11-04-16-49-41.png)

### 4.8.2. 迭代

![](_image/2021-11-04-16-50-27.png)

### 4.8.3. Json集合

```js
// 脚本处理
var collection = S('{ "collection" : ["System 1", "System 3"] }');
execution.setVariable("collection", collection);
```

```xml
<!--Xml定义-->
<multiInstanceLoopCharacteristics 
  camunda:collection="${collection.prop('collection').elements()}" 
  camunda:elementVariable="collectionElem" />
```

### 4.8.3. 补偿

![](_image/2021-11-04-16-52-09.png)

# 5. Comunda中的BPMN网关

